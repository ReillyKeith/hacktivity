# Generated by Selenium IDE
import pytest
import time
import json
import random
import sys
from selenium import webdriver
from selenium import common
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.options import Options  
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from selenium.common.exceptions import NoSuchElementException



class TestHackCheck():
  def setup_method(self, method):
    my_settings = Options()  
    my_settings.add_argument("--headless")  
    self.driver = webdriver.Chrome(executable_path='chromedriver',chrome_options=my_settings)
    self.vars = {}
  
  def teardown_method(self, method):
    self.driver.quit()
  
  def test_hackCheck(self):
    
    reload(sys)
    sys.setdefaultencoding('utf-8')
    # Test name: HackCheck
    # Step # | name | target | value
    #Add a loop here to read from a file of know reports 
    #Now grab the data that is needed from the report 

    # Open the file with read only permit
    f = open('hackerone_records')

    # open file to write to
    fw = open("DataFile1.txt", "a")

    # use readline() to read the first line 
    line = f.readline()
    # use the read line to read further.
    # If the file is not empty keep reading one line
    # at a time, till the file is empty
    while line:
        # in python 2+
        # print line
        # in python 3 print is a builtin function, so
        url = "https://hackerone.com/reports/" + line

        # 1 | open | /reports/727 | 
        self.driver.get(url)

        time.sleep(9)

        # 2 | setWindowSize | 1789x1119 | 
        self.driver.set_window_size(1789, 1119)

        # Now to grab some data that will be used for DB
        # BugName, BugNum, State, Disclosed, ReportedTo, Severity, Visibility, Bounty
        # Above is the data that needs to be saved for each issue
        Bugname = self.driver.find_element_by_xpath("//div[@class='report-heading__report-title break-all spec-report-title']").text
        State = self.driver.find_element_by_xpath("//td[@class='report-meta__table-cell spec-meta-item-contents']").text 
        Disclosed = self.driver.find_element_by_xpath("//strong").text 
        ReportedTo = self.driver.find_element_by_xpath("//a[@class='daisy-link routerlink daisy-link']").text 
        Visibility = self.driver.find_element_by_xpath("//span[@class='spec-visibility-label']").text 
        Severity = self.driver.find_element_by_xpath("//span[@class='spec-severity-rating']").text 
        Weakness = self.driver.find_element_by_xpath("//tr[@class='report-meta__table-row spec-weakness-meta-item']").text 

        print ();

        Bounty = "Bounty Not Public"
        try:
          Bounty = self.driver.find_element_by_xpath("//tr[@class='report-meta__table-row spec-bounty-amount-meta-item']").text 
        except NoSuchElementException:
          time.sleep(1)

        print ("Bug Title: " + Bugname);
        print ("Bug State: " + State);
        print ("Bug divulge: " + Disclosed);
        print ("Bug Reported to: " + ReportedTo);
        print ("Bug visibility: " + Visibility);
        print ("Bug Severity: " + Severity);
        print ("Bug Weakness: " + Weakness);
        print ("Bug Bounty: " + Bounty);
        print ("Bug Number: " + line);

        #Once all the data is in here I can
        #BUG_NAME=Bugname.decode('ascii').encode('utf-8').strip() 
        #then run the sql update command
        fw.write(str(random.randrange(99999999999))+"\t"+str(Bugname)+"\t"+State+"\t"+Disclosed+"\t"+ReportedTo+"\t"+Visibility+"\t"+Severity+"\t"+Bounty+"\t"+Weakness+"\t"+line.rstrip("/n"))

        # use realine() to read next line
        line = f.readline()
    f.close()